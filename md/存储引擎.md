# 存储引擎笔记

## 最简单的存储引擎

```bash
#!/bin/bash

db_set() {
  echo "$1,$2" >> database
}

db_get() {
  grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

这其实就是一个简单的追加式文件结构（append-only file），或可将文件中存储的记录视为日志。每次通过 key 从文件中查询时，取出最新的一条记录即可得到目标数据。


## 哈希索引存储引擎（示例：Bitcask）

实现上的重要细节如下：

* 文件格式：二进制格式（段文件）
* 数据压缩：日志文件分为多个段（segment），当段文件达到一定大小时关闭并在新的段中写。后台线程会对已关闭的多个段进行合并与压缩，处理完后可以安全删除旧段并切换读取到合并后的段。
* 删除记录：在数据文件中追加特殊的删除记录（tombstone），合并时丢弃已删除键的所有值。
* 崩溃恢复：定期将每个段的 hash map 快照保存到磁盘，重启时加载快照以加速恢复。
* 部分写入的记录：追加记录过程中若发生崩溃，可通过校验值检测并丢弃损坏的记录。
* 并发控制：写入按严格先后顺序追加到文件，通常使用单写线程以保证顺序性。

局限性：

* 哈希表（索引）必须全部放入内存，数据量大时会占用大量内存。
* 区间查询效率低。


## LSM-Tree 存储引擎

LSM-Tree（Log-Structured Merge Tree）是一种基于合并与压缩排序文件的存储引擎。

### SSTable（Sorted String Table）

* 全称：Sorted String Table，排序字符串表。
* 要求：段文件中的 key-value 对按 key 排序，每个 key 在同一段文件中只能存在一次。

优点：

* 合并段高效：类似归并排序算法，同时读取多个输入段，比较各段的首项并按 key 顺序拷贝到输出文件。若多个段中存在相同 key，保留最新段的值并丢弃旧值。
* 不必在内存中保存所有 key 的索引，可使用稀疏索引结构。由于段文件有序，稀疏索引可定位大致范围后在段内扫描。
* 读请求常常需扫描范围内的多个 key-value 对，可将记录保存到块（block）并压缩，稀疏索引指向块的开头以提高效率。


### 构建和维护 SSTables

* 在内存中维护有序结构（例如红黑树或跳表）。
* 当内存表（memtable）超过阈值（通常几 MB）时，将其作为 SSTable 写入磁盘。内存表已保持按 key 排序，写磁盘较高效。写入过程中会创建新的内存表实例继续接受写操作。
* 读请求先在内存表中查找，然后按时间顺序查找最新的磁盘段文件，依次向更老的段查找直到命中或不存在。
* 后台线程周期性执行段合并（compaction），合并多个段并丢弃已被覆盖或删除的值。

若数据库崩溃，未刷入磁盘的内存表数据会丢失。为避免丢失，通常会保留顺序追加的日志（write-ahead log），每次写入都会追加到该日志。内存表写入 SSTable 后可删除相应的日志文件。
