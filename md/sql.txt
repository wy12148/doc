基础概念
数据库：保存有组织的数据的容器
常见误区：用户使用的软件被称为数据库管理系统（DBMS），数据库是通过DBMS创建和操纵的容器。
表：特定类型数据的结构化清单
schema：元数据信息，关于数据库和表的布局及特性的信息。
列：表中的一个字段。所有表都是由一个或多个列组成的。
行：表中的一个记录。
主键（primary key）：一列（或几列），其值能够唯一标识表中每一行。

主键应该满足的条件：
* 任意两行都不具有相同的主键值； 
* 每一行都必须具有一个主键值（主键列不允许空值NULL）； 
* 主键列中的值不允许修改或更新； 
* 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。
注意：尽管现在的数据库允许通过update修改主键，但是担心有外键约束，最好的使用方式是创建一个新的记录，并将旧记录标记为失效状态。

查询语法
DISTINCT
对结果集进行去重
select distinct vend_id from products;

LIMIT
限制结果集数量
SELECT prod_name from products LIMIT 5;

OFFSET
偏移量
SELECT prod_name from products OFFSET 5;
offset和limit位置可以互换，下面二者结果相同
SELECT prod_name from products OFFSET 5 LIMIT 3;
SELECT prod_name from products LIMIT 3 OFFSET 5;

ORDER BY
排序，可以通过被选择列或者非被选择列进行排序
SELECT prod_id, prod_price, prod_name 
FROM Products 
ORDER BY prod_price, prod_name; 
还有一种按照选择列的位置进行排序
SELECT prod_id, prod_price, prod_name 
FROM Products 
ORDER BY 2，3；
上述两条语句结果相同。
注意，使用位置排序时就无法使用非选择列了
order by默认按照升序排列，可以通过在排序列名后加上 DESC 要求此列降序排列

WHERE
过滤条件
注意ORDER BY应该在WHERE子句之后
where除了常规的 = 、!= 、> 、>= 、<  、<= 、!> 、 !<这些操作符还
还有BETWEEN a AND b用来过滤a和b之间的值
还有IS NULL空值检查

AND/OR
组合过滤条件
注意：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括 号明确地分组操作符。不要过分依赖默认求值顺序，即使它确实如你 希望的那样。使用圆括号没有什么坏处，它能消除歧义。
﻿
IN
IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。
是OR操作符的一种简便写法
SELECT prod_name, prod_price FROM Products WHERE vend_id IN ('DLL01','BRS01') ORDER BY prod_name;
SELECT prod_name, prod_price FROM Products WHERE vend_id = 'DLL01' OR vend_id = 'BRS01' ORDER BY prod_name;
上述两条sql等效
﻿
NOT
否认其后的过滤条件

LIKE与通配符
%：匹配任意数量
_：匹配单个字符
[]：匹配字符集中的一个字符
[^]：不匹配字符集中的字符

计算字段
例如多个列之间的内容进行拼接，视dbms不同可以使用 '+'、'||'操作符或者Concat函数进行处理
还有trim, ltrim,rtrim等用来去掉空格

别名AS
为计算字段或者某些字段赋予一个新的名字，且可以在子句中使用。
例如别名用来排序使用

COUNT函数
使用COUNT(*)计数表中的行
使用COUNT(column)对特定列中具有值的行进行计数，这里会忽略NULL值

GROUP BY
对数据进行分组，分组后COUNT, SUM，MAX等聚集函数就可以在每个组中生效了
NULL也会被分为一个组
GROUP BY出现在WHERE子句之后，ORDER BY子句之前

HAVING
HAVING和WHERE关键字在使用上一模一样，唯一的不同是
WHERE对行进行过滤
HAVING对分组进行过滤

子查询
子查询的SELECT作为父查询中的WHERE条件使用是很方便的
SELECT cust_name, cust_contact FROM Customers WHERE cust_id IN (SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01'));
子查询也可以作为父查询的一个检索项存在
SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders FROM Customers ORDER BY cust_name;

子查询作为父查询的计算字段当作检索项存在时非常不直观，不如join好用
但是注意子查询只能检索一列内容返回

联结
自联结：
使用子查询可以这样做：
SELECT cust_id, cust_name, cust_contact 
FROM Customers 
WHERE cust_name = (SELECT cust_name 
                   FROM Customers 
                   WHERE cust_contact = 'Jim Jones'); 
通过别名使用自联结一个查询更快：
SELECT c1.cust_id, c1.cust_name, c1.cust_contact 
FROM Customers AS c1, Customers AS c2 
WHERE c1.cust_name = c2.cust_name 
 AND c2.cust_contact = 'Jim Jones';  

内联结：
返回两表匹配成功的行

外联结：
例如左外联结会包含匹配成功的行，左表中未与右表匹配成功的行也会存在，但是右表中相关字段为空值

插入
INSERT [INTO] tablename[(columns)] VALUES();
INSERT [INTO] tablename[(columns)] SELECT columns FROM tablename;

整表复制语法
CREATE TABLE CustCopy AS SELECT * FROM Customers;
SELECT * INTO CustCopy FROM Customers;

更新语法
UPDATE Customers 
SET cust_contact = 'Sam Roberts', 
cust_email = 'sam@toyland.com' 
WHERE cust_id = 1000000006; 

删除语法
DELETE [FROM] Customers 
WHERE cust_id = 1000000006; 
直接清空表的所有内容
TRUNCATE TABLE tablename;

表格操作
创建表格
CREATE TABLE products_aaa
( 
prod_id       CHAR(10)  NOT NULL,
vend_id       CHAR(10)  NOT NULL,
prod_name     CHAR(10)  NOT NULL,
prod_price    DECIMAL(8, 2) NOT NULL DEFAULT 1.23,
prod_desc     VARCHAR(1000) NULL
); 

修改表格
ALTER TABLE Vendors ADD vend_phone CHAR(20);

重命名表
查询DBMS相关文档，不同DBMS操作可能不同

视图
视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。 视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新 格式化或保护基础数据。

视图创建
几乎和整表复制语法相同
使用视图简化联结的示例：
CREATE VIEW ProductCustomers AS 
SELECT cust_name, cust_contact, prod_id 
FROM Customers, Orders, OrderItems 
WHERE Customers.cust_id = Orders.cust_id 
AND OrderItems.order_num = Orders.order_num;
﻿
使用视图重新格式化检索出的数据示例：
直接写法：
SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')' 
AS vend_title 
FROM Vendors 
ORDER BY vend_name; 

视图写法：
CREATE VIEW VendorLocations AS
SELECT rtrim(vend_name) || '()' || rtrim(vend_country) || ')'
AS vend_title
FROM vendors;

SELECT vend_title
FROM vendorlocations;

视图查询
同表查询用法一致

存储过程
存储过程就是为以后使用而保存的一条 或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。
存储过程很强大，但是其可能并不安全，目前接触的较少，可以在需要使用的时候再进行学习


事务
 事务（transaction）指一组SQL语句； 
 回退（rollback）指撤销指定SQL语句的过程； 
 提交（commit）指将未存储的SQL语句结果写入数据库表； 
 保留点（savepoint）指事务处理中设置的临时占位符（placeholder）， 可以对它发布回退（与回退整个事务处理不同）。


一般情况下是这样的
BEGIN
SAVE TRANSACTION point；
IF ERROR ROLLBACK TRANSCATION point;
COMMIT
具体的写法请查看相关dbms的文档

游标
cursor可以按需要学习

约束
主键约束
在创建表时定义它，例如
CREATE TABLE Vendors  
( 
    vend_id         CHAR(10)       NOT NULL PRIMARY KEY,  
    vend_name       CHAR(50)       NOT NULL, 
    vend_address    CHAR(50)       NULL, 
    vend_city       CHAR(50)       NULL, 
    vend_state      CHAR(5)        NULL, 
    vend_zip        CHAR(10)       NULL, 
    vend_country    CHAR(50)       NULL 
); 
通过修改表时定义它
ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id);
有些dbms只允许在创建表时定义主键，请注意

外键
创建表时定义
CREATE TABLE Orders 
( 
order_num    INTEGER    NOT NULL PRIMARY KEY, 
order_date   DATETIME   NOT NULL, 
cust_id      CHAR(10)   NOT NULL REFERENCES Customers(cust_id) 
); 
修改表时定义
ALTER TABLE Orders 
ADD CONSTRAINT 
FOREIGN KEY (cust_id) REFERENCES Customers (cust_id); 

外键有助防止意外删除，定义外键后，外键不允许删除在另外一个表中具有关联行的行。
但是注意不要启动级联删除，不然可能会因为删除某条记录导致大量数据意外的被级联删除。
现在工程中通过使用软删除，级添加一列用来标记记录是否被删除或者是否有效，可以使用bool类型的is_delete字段，更强大的是使用一个date字段来记录删除时间，未删除的行此字段为NULL

唯一约束
类似于主 键，但存在以下重要区别。 
 表可包含多个唯一约束，但每个表只允许一个主键。 
 唯一约束列可包含NULL值。  唯一约束列可修改或更新。 
 唯一约束列的值可重复使用。 
 与主键不一样，唯一约束不能用来定义外键。
示例：employees 表是一个使用约束的例子。每个雇员都有唯一的社会安全号， 但我们并不想用它作主键，因为它太长（而且我们也不想使该信息容易 利用）。因此，每个雇员除了其社会安全号外还有唯一的雇员ID（主键）。

检查约束
检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检 查约束的常见用途有以下几点。 
 检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。 
 指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天 起一年后的日期。 
 只允许特定的值。例如，在性别字段中只允许M或F。
示例：
CREATE TABLE OrderItems 
( 
order_num     INTEGER     NOT NULL, 
order_item    CHAR(10)    NOT NULL,
prod_id       INTEGER     NOT NULL, 
quantity      INTEGER     NOT NULL CHECK (quantity > 0),
item_price    MONEY       NOT NULL
); 

索引
索引需要注意的地方：
 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。 在执行这些操作时，DBMS必须动态地更新索引。 
 索引数据可能要占用大量的存储空间。 
 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多 可能值的数据（如姓或名），能通过索引得到那么多的好处。 
 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数 据，则该数据可能适合做索引。 
 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州 加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。

创建索引
CREATE INDEX prod_name_ind 
ON Products (prod_name);

触发器
创建触发器示例
CREATE TRIGGER customer_state 
AFTER INSERT OR UPDATE 
FOR EACH ROW 
BEGIN
UPDATE Customers 
SET cust_state = Upper(cust_state) WH
ERE Customers.cust_id = :OLD.cust_id 
END;
触发器的创建需要参考具体的DBMS文档，不同DBMS创建的方式不同
